# Mathematical logic course | Spring 2022

# Table of Contents
1. [Normal forms converter](#hw-1)
2. [N-Queens problem](#hw-2)
3. [Coq proofs](#hw-3)
4. [Coq proofs 2: Judgment Day](#hw-4)
5. [Verification of the arithmetic expression compiler into stack machine programs](#hw-5)
6. [TODO](#hw-6)

<div id='hw-1'/>

## HW №1: Normal forms converter

### Задание
Реализовать 3 функции:

- приведение произвольной пропозициональной формулы к отрицательной нормальной форме (NNF)
- приведение произвольной пропозициональной формулы к дизъюнктивной нормальной форме (DNF)
- приведение произвольной пропозициональной формулы к конъюнктивной нормальной форме (CNF)
### Требования к реализации
1. Для реализации рекомендуем использовать типизированные функциональные языки программирования, такие как Haskell, OCaml, Scala и др. Однако, любой другой язык програмирования тоже подойдёт.
2. Ваше решение должно быть хорошо читаемым, содержать комментарии для критичных частей, содержать инструкции по запуску и продуманные тесты. 

3. Рекомендуется использовать фреймворки для тестирования приложений командной строки подобные cram (https://github.com/brodie/cram), клоны которого существуют для многих языков программирования (это потребует реализации pretty-printer'а и парсера для формул).

4. В идеале инструкции по запуску должны быть понятными машине и для вашего репозитория должен быть настроен CI с запуском тестов.

### Дополнительные баллы
- Для последнего пункта экстра баллы можно получить за алгоритм Цейтина.
- Помимо unit-тестов можно использовать рандомизированное тестирование (QuickCheck и подобные вещи), если хотите получить экстра баллы.

<div id='hw-2'/>

## HW №2: N-Queens problem 

### Задание
Решить задачу о `n` ферзях, сведя её к `SAT`-задаче. Сгенерируйте входной файл для SAT-решателя программно и вызовите решатель. Ваша программа должна вернуть расстановку.
(См. https://ru.wikipedia.org/wiki/Задача_о_восьми_ферзях)

### Требования:
На вход подается число `n`.
Ваша программа должная вернуть расстановку.
Cделать это по следующей схеме:
    - генерация формулы
    - перевод ее в cnf
    - запуск SAT решателя

### Дополнительные баллы    
Доп баллы можно получить за использование API солверов и любую креативность.

<div id='hw-3'/>

## HW3: Coq proofs

### Задание
Записать свои термы вместо `_`. В качестве ответа прикрепить репозиторий с этим файлом, просто `.v` файл или текст.

### Дополнительные баллы    
Последнее задание бонусное.

<div id='hw-4'/>

## HW №4: Coq proofs 2: Judgment Day
### Задание
Записать свои термы вместо `provide_solution`. В качестве ответа прикрепить репозиторий с этим файлом, просто `.v` файл или текст.

**Спойлер №1**: Лемма `LEM_iff_Frobenius2` -- это задание повышенной сложности. Нужно подумать чем инстанцировать `A : Type, P : A -> Prop` и `Q : Prop` в определении `Frobenius2`.

**Спойлер №2**: Высказывания, т.е. термы типа `Prop`, также являются типами, т.е. термами типа `Type`.


<div id='hw-5'/>

## HW №5: Verification of the arithmetic expression compiler into stack machine programs

Домашняя работа является продолжением последнего семинара, где мы разбирали верификацию очень простого компилятора арифметических выражений в программы для стековой машины.

На семинаре мы успели разобрать доказательства для машины, которая игнорировала ошибочное состояние, когда стека не хватало и продолжала выполнять программу дальше. Это существенно упрощало доказательство корректности.

### Задание
В данной домашней работе нужно верифицировать компилятор для стековой машины, которая немедленно завершает выполнение при возникновении ошибки и возвращает пустой стек.

Заготовка задания приведена ниже -- нужно доказать теорему `compile_correct`.

*Внимание:* менять семантики машины или интерпретатора арифметических выражений нельзя -- теорема `compile_correct` точно доказуема :)

<div id='hw-6'/>

## TODO